#!/usr/bin/env bun

import console from 'console';
import { mkdirSync, writeFileSync, existsSync, readFileSync } from 'fs';
import { dirname, join, resolve, relative } from 'path';
import { parseArgs } from 'util';

import type { FSWatcher } from 'chokidar';
import { watch } from 'chokidar';
import { getTsconfig } from 'get-tsconfig';
import { format as formatWithOxfmt } from 'oxfmt';

import { colorText } from '../utils/cli.js';

// TODO on startup check cwd for oxfmt config and use that instead of my default

type TsConfigJson = Record<string, any>;

const DEFAULT_TEST_EXCLUDES = [
  '**/*.test.ts',
  '**/*.test.tsx',
  '**/*.spec.ts',
  '**/*.spec.tsx',
  '**/__tests__/**',
  '**/tests/**'
];
const GENERATED_FILE_HEADER = '// generated by ts-build-config';

const LABEL = colorText('cyan', '[ts-build-config]');
const formatPath = (filePath: string): string => colorText('dim', relative(process.cwd(), filePath));
const logInfo = (message: string): void => console.log(`${LABEL} ${message}`);
const logWarn = (message: string): void => console.warn(`${LABEL} ${colorText('yellow', message)}`);
const logError = (message: string): void => console.error(`${LABEL} ${colorText('red', message)}`);

function asArray<T>(v: unknown): T[] {
  if (!v) return [];
  return Array.isArray(v) ? (v as T[]) : [v as T];
}

function isObject(v: unknown): v is Record<string, any> {
  return !!v && typeof v === 'object' && !Array.isArray(v);
}

function uniq(items: string[]): string[] {
  return Array.from(new Set(items));
}

function normalizeRefPath(baseTsconfigPath: string, refPath: string): string {
  // TS project references are relative to the tsconfig location
  const baseDir = dirname(baseTsconfigPath);
  // refPath may point to a folder (containing tsconfig.json) or a file
  const abs = resolve(baseDir, refPath);
  return abs;
}

function resolveReferencedTsconfigPath(refAbsPath: string): string | null {
  // If they referenced a file directly, use it
  if (refAbsPath.endsWith('.json')) {
    return existsSync(refAbsPath) ? refAbsPath : null;
  }

  // Otherwise assume it's a directory containing tsconfig.json
  const candidate = join(refAbsPath, 'tsconfig.json');
  if (existsSync(candidate)) return candidate;

  // Some repos use tsconfig.base.json or similar; we won't guess.
  return null;
}

function readTsconfig(tsconfigPath: string): TsConfigJson {
  const res = getTsconfig(tsconfigPath);
  if (!res) {
    throw new Error(`get-tsconfig could not load: ${tsconfigPath}`);
  }
  // get-tsconfig returns a parsed config object (includes extends resolved).
  // We want to write a build tsconfig that extends the original file path,
  // so we mostly only need top-level fields we change (exclude/compilerOptions).
  return res.config as TsConfigJson;
}

function computeExtraExcludes(config: TsConfigJson): string[] {
  const extra: string[] = [...DEFAULT_TEST_EXCLUDES];

  // If the tsconfig includes ./tests (or tests) explicitly, ensure it is excluded in build config.
  const includes = asArray<string>(config.include);
  for (const inc of includes) {
    const norm = inc.replace(/\\/g, '/').replace(/\/+$/, '');
    if (norm === './tests' || norm === 'tests' || norm.startsWith('./tests/') || norm.startsWith('tests/')) {
      extra.push('./tests/**');
      break;
    }
  }

  return uniq(extra);
}

function withTrailingNewline(value: string): string {
  return value.endsWith('\n') ? value : `${value}\n`;
}

async function formatBuildTsconfigJson(config: TsConfigJson): Promise<string> {
  const fallback = JSON.stringify(config, null, 2);

  try {
    const result = await formatWithOxfmt('tsconfig.build.json', fallback, {
      useTabs: false,
      singleQuote: true,
      trailingComma: 'none',
      printWidth: 120,
      objectWrap: 'collapse',
      semi: true,
      proseWrap: 'always',
      sortPackageJson: { sortScripts: true },
      sortImports: {}
    });
    if (!result.errors.length && typeof result.code === 'string' && result.code.length > 0) {
      return withTrailingNewline(result.code);
    }
  } catch {
    // Fallback to plain JSON below.
  }

  return withTrailingNewline(fallback);
}

async function writeBuildTsconfig(tsconfigPath: string, config: TsConfigJson, dryRun: boolean): Promise<string> {
  const dir = dirname(tsconfigPath);
  const outPath = join(dir, 'tsconfig.build.json');

  const existingExclude = asArray<string>(config.exclude);
  const mergedExclude = uniq([...existingExclude, ...computeExtraExcludes(config)]);

  const buildConfig: TsConfigJson = { extends: './tsconfig.json', compilerOptions: {}, exclude: mergedExclude };
  const refs = asArray<unknown>(config.references);
  if (refs.length > 0) {
    buildConfig.references = refs;
  }

  // If original compilerOptions exists, keep build-specific overrides minimal.
  // But ensure emit is enabled if base tsconfig has noEmit: true (common for editor configs).
  const baseCO = isObject(config.compilerOptions) ? config.compilerOptions : {};
  if (baseCO.noEmit === true) {
    buildConfig.compilerOptions.noEmit = false;
  }

  // Keep outDir/rootDir if already set in base; do not guess.
  // If you want to force them, do it in the base tsconfig.json or pass flags later.

  if (!dryRun) {
    mkdirSync(dir, { recursive: true });
    const formattedJson = await formatBuildTsconfigJson(buildConfig);
    writeFileSync(outPath, `${GENERATED_FILE_HEADER}\n${formattedJson}`, 'utf8');
  }

  return outPath;
}

function isGeneratedByThisScript(filePath: string): boolean {
  try {
    const contents = readFileSync(filePath, 'utf8');
    const firstLine = contents.split(/\r?\n/, 1)[0]?.trim() ?? '';
    return firstLine === GENERATED_FILE_HEADER;
  } catch {
    return false;
  }
}

function getProjectRefs(tsconfigPath: string, config: TsConfigJson): string[] {
  const refs = asArray<any>(config.references);
  const result: string[] = [];

  for (const r of refs) {
    if (!r) continue;
    const refPath = typeof r === 'string' ? r : r.path;
    if (!refPath || typeof refPath !== 'string') continue;

    const abs = normalizeRefPath(tsconfigPath, refPath);
    const resolved = resolveReferencedTsconfigPath(abs);
    if (resolved) result.push(resolved);
  }

  return uniq(result);
}

function shouldUseBuildConfig(tsconfigPath: string, force: boolean): boolean {
  const outPath = join(dirname(tsconfigPath), 'tsconfig.build.json');
  if (!existsSync(outPath)) return true;
  if (force) return true;
  return isGeneratedByThisScript(outPath);
}

function asPosixPath(filePath: string): string {
  return filePath.replace(/\\/g, '/');
}

function ensureDotRelative(filePath: string): string {
  if (filePath.startsWith('.')) return filePath;
  return `./${filePath}`;
}

function replaceRefsWithBuildConfigs(
  tsconfigPath: string,
  config: TsConfigJson,
  buildConfigSet: Set<string>
): TsConfigJson {
  const refs = asArray<any>(config.references);
  if (refs.length === 0) return config;

  const baseDir = dirname(tsconfigPath);
  const mapped = refs.map((refEntry) => {
    if (!refEntry) return refEntry;

    const refPath = typeof refEntry === 'string' ? refEntry : refEntry.path;
    if (!refPath || typeof refPath !== 'string') return refEntry;

    const normalizedRefPath = ensureDotRelative(asPosixPath(refPath));
    const abs = normalizeRefPath(tsconfigPath, refPath);
    const resolvedRefTsconfig = resolveReferencedTsconfigPath(abs);
    if (!resolvedRefTsconfig) {
      if (typeof refEntry === 'string') return normalizedRefPath;
      return { ...refEntry, path: normalizedRefPath };
    }
    if (!buildConfigSet.has(resolvedRefTsconfig)) {
      if (typeof refEntry === 'string') return normalizedRefPath;
      return { ...refEntry, path: normalizedRefPath };
    }

    const buildRefPath = join(dirname(resolvedRefTsconfig), 'tsconfig.build.json');
    const relativeBuildRef = ensureDotRelative(asPosixPath(relative(baseDir, buildRefPath)));

    if (typeof refEntry === 'string') {
      return relativeBuildRef;
    }

    return { ...refEntry, path: relativeBuildRef };
  });

  return { ...config, references: mapped };
}

type GenerateOptions = { dryRun: boolean; force: boolean; verbose: boolean };

async function generateBuildConfigs(
  entry: string,
  options: GenerateOptions
): Promise<{ created: { src: string; out: string }[]; visitedConfigs: string[] }> {
  const { dryRun, force, verbose } = options;

  const loadedConfigs = new Map<string, TsConfigJson>();
  const visited = new Set<string>();
  const queue: string[] = [entry];
  const created: { src: string; out: string }[] = [];

  // First pass: discover the full referenced tsconfig graph and load configs.
  while (queue.length) {
    const tsconfigPath = queue.shift()!;
    if (visited.has(tsconfigPath)) continue;
    visited.add(tsconfigPath);

    let cfg: TsConfigJson;
    try {
      cfg = readTsconfig(tsconfigPath);
    } catch (e) {
      logWarn(`Skipping unreadable config: ${formatPath(tsconfigPath)}`);
      if (verbose) console.warn(e);
      continue;
    }
    loadedConfigs.set(tsconfigPath, cfg);

    const refs = getProjectRefs(tsconfigPath, cfg);
    for (const r of refs) queue.push(r);
  }

  const discoveredConfigs = Array.from(visited).filter((path) => loadedConfigs.has(path));
  const buildConfigSet = new Set(discoveredConfigs.filter((path) => shouldUseBuildConfig(path, force)));

  // Second pass: write build configs with rewritten references.
  for (const tsconfigPath of discoveredConfigs) {
    const cfg = loadedConfigs.get(tsconfigPath)!;
    const outPath = join(dirname(tsconfigPath), 'tsconfig.build.json');
    if (!buildConfigSet.has(tsconfigPath)) {
      if (verbose) {
        logInfo(`Skip ${formatPath(outPath)} (manual file, use ${colorText('bold', '--force')})`);
      }
    } else {
      const rewrittenCfg = replaceRefsWithBuildConfigs(tsconfigPath, cfg, buildConfigSet);
      const written = await writeBuildTsconfig(tsconfigPath, rewrittenCfg, dryRun);
      created.push({ src: tsconfigPath, out: written });
      if (verbose || dryRun) {
        const verb = dryRun ? colorText('yellow', '[dry-run] write') : colorText('green', 'write');
        logInfo(`${verb} ${formatPath(written)} <- ${formatPath(tsconfigPath)}`);
      }
    }
  }

  if (!verbose && !dryRun) {
    logInfo(`${colorText('green', 'updated')} ${created.length} tsconfig.build.json file(s)`);
  }

  return { created, visitedConfigs: Array.from(visited) };
}

function createRegenerator(
  entry: string,
  options: GenerateOptions
): { run: (reason?: string) => Promise<void>; syncWatchedConfigs: (watcher: FSWatcher) => void } {
  let isRunning = false;
  let rerunRequested = false;
  let watchedConfigs = new Set<string>();

  const syncWatchedConfigs = (watcher: FSWatcher): void => {
    if (watchedConfigs.size === 0) return;
    watcher.add(Array.from(watchedConfigs));
  };

  const run = async (reason?: string): Promise<void> => {
    if (isRunning) {
      rerunRequested = true;
      return;
    }
    isRunning = true;

    try {
      do {
        rerunRequested = false;
        if (reason) {
          logInfo(`${colorText('cyan', 'regenerate')} (${reason})`);
          reason = undefined;
        }
        const result = await generateBuildConfigs(entry, options);
        watchedConfigs = new Set(result.visitedConfigs);
      } while (rerunRequested);
    } finally {
      isRunning = false;
    }
  };

  return { run, syncWatchedConfigs };
}

async function main(): Promise<void> {
  const { values } = parseArgs({
    args: process.argv.slice(2),
    options: {
      config: { type: 'string', short: 'c' },
      dryRun: { type: 'boolean' },
      force: { type: 'boolean' }, // overwrite files not generated by this script
      watch: { type: 'boolean', short: 'w' },
      verbose: { type: 'boolean', short: 'v' }
    }
  });

  const entry = values.config ? resolve(values.config) : null;
  if (!entry) {
    logError('Missing required flag: --config <path/to/tsconfig.json>');
    process.exit(1);
  }
  if (!existsSync(entry)) {
    logError(`Config file not found: ${formatPath(entry)}`);
    process.exit(1);
  }

  const dryRun = values.dryRun === true;
  const force = values.force === true;
  const watchMode = values.watch === true;
  const verbose = values.verbose === true;
  const options: GenerateOptions = { dryRun, force, verbose };

  const regenerator = createRegenerator(entry, options);
  await regenerator.run('initial run');

  if (!watchMode) {
    return;
  }

  logInfo(`watching ${colorText('cyan', 'tsconfig')} changes...`);
  const watcher = watch([], {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: { stabilityThreshold: 300, pollInterval: 100 }
  });
  regenerator.syncWatchedConfigs(watcher);

  watcher.on('change', async (filePath) => {
    logInfo(`${colorText('cyan', 'change')} ${formatPath(filePath)}`);
    await regenerator.run(`changed ${relative(process.cwd(), filePath)}`);
    regenerator.syncWatchedConfigs(watcher);
  });

  watcher.on('add', async (filePath) => {
    logInfo(`${colorText('cyan', 'add')} ${formatPath(filePath)}`);
    await regenerator.run(`added ${relative(process.cwd(), filePath)}`);
    regenerator.syncWatchedConfigs(watcher);
  });

  watcher.on('unlink', async (filePath) => {
    logInfo(`${colorText('yellow', 'remove')} ${formatPath(filePath)}`);
    await regenerator.run(`removed ${relative(process.cwd(), filePath)}`);
    regenerator.syncWatchedConfigs(watcher);
  });
}

main().catch((err) => {
  logError('Unhandled error');
  console.error(err);
  process.exit(1);
});
