#!/usr/bin/env bun

import console from 'console';
import { mkdirSync, writeFileSync, existsSync, readFileSync } from 'fs';
import { dirname, join, resolve, relative } from 'path';
import { parseArgs } from 'util';

import type { FSWatcher } from 'chokidar';
import { watch } from 'chokidar';
import { getTsconfig } from 'get-tsconfig';

type TsConfigJson = Record<string, any>;

const DEFAULT_TEST_EXCLUDES = [
  '**/*.test.ts',
  '**/*.test.tsx',
  '**/*.spec.ts',
  '**/*.spec.tsx',
  '**/__tests__/**',
  '**/tests/**'
];
const GENERATED_FILE_HEADER = '// generated by ts-build-config';

function asArray<T>(v: unknown): T[] {
  if (!v) return [];
  return Array.isArray(v) ? (v as T[]) : [v as T];
}

function isObject(v: unknown): v is Record<string, any> {
  return !!v && typeof v === 'object' && !Array.isArray(v);
}

function uniq(items: string[]): string[] {
  return Array.from(new Set(items));
}

function normalizeRefPath(baseTsconfigPath: string, refPath: string): string {
  // TS project references are relative to the tsconfig location
  const baseDir = dirname(baseTsconfigPath);
  // refPath may point to a folder (containing tsconfig.json) or a file
  const abs = resolve(baseDir, refPath);
  return abs;
}

function resolveReferencedTsconfigPath(refAbsPath: string): string | null {
  // If they referenced a file directly, use it
  if (refAbsPath.endsWith('.json')) {
    return existsSync(refAbsPath) ? refAbsPath : null;
  }

  // Otherwise assume it's a directory containing tsconfig.json
  const candidate = join(refAbsPath, 'tsconfig.json');
  if (existsSync(candidate)) return candidate;

  // Some repos use tsconfig.base.json or similar; we won't guess.
  return null;
}

function readTsconfig(tsconfigPath: string): TsConfigJson {
  const res = getTsconfig(tsconfigPath);
  if (!res) {
    throw new Error(`get-tsconfig could not load: ${tsconfigPath}`);
  }
  // get-tsconfig returns a parsed config object (includes extends resolved).
  // We want to write a build tsconfig that extends the original file path,
  // so we mostly only need top-level fields we change (exclude/compilerOptions).
  return res.config as TsConfigJson;
}

function computeExtraExcludes(config: TsConfigJson): string[] {
  const extra: string[] = [...DEFAULT_TEST_EXCLUDES];

  // If the tsconfig includes ./tests (or tests) explicitly, ensure it is excluded in build config.
  const includes = asArray<string>(config.include);
  for (const inc of includes) {
    const norm = inc.replace(/\\/g, '/').replace(/\/+$/, '');
    if (norm === './tests' || norm === 'tests' || norm.startsWith('./tests/') || norm.startsWith('tests/')) {
      extra.push('./tests/**');
      break;
    }
  }

  return uniq(extra);
}

function writeBuildTsconfig(tsconfigPath: string, config: TsConfigJson, dryRun: boolean): string {
  const dir = dirname(tsconfigPath);
  const outPath = join(dir, 'tsconfig.build.json');

  const existingExclude = asArray<string>(config.exclude);
  const mergedExclude = uniq([...existingExclude, ...computeExtraExcludes(config)]);

  const buildConfig: TsConfigJson = { extends: './tsconfig.json', compilerOptions: {}, exclude: mergedExclude };

  // If original compilerOptions exists, keep build-specific overrides minimal.
  // But ensure emit is enabled if base tsconfig has noEmit: true (common for editor configs).
  const baseCO = isObject(config.compilerOptions) ? config.compilerOptions : {};
  if (baseCO.noEmit === true) {
    buildConfig.compilerOptions.noEmit = false;
  }

  // Keep outDir/rootDir if already set in base; do not guess.
  // If you want to force them, do it in the base tsconfig.json or pass flags later.

  if (!dryRun) {
    mkdirSync(dir, { recursive: true });
    writeFileSync(outPath, `${GENERATED_FILE_HEADER}\n${JSON.stringify(buildConfig, null, 2)}\n`, 'utf8');
  }

  return outPath;
}

function isGeneratedByThisScript(filePath: string): boolean {
  try {
    const contents = readFileSync(filePath, 'utf8');
    const firstLine = contents.split(/\r?\n/, 1)[0]?.trim() ?? '';
    return firstLine === GENERATED_FILE_HEADER;
  } catch {
    return false;
  }
}

function getProjectRefs(tsconfigPath: string, config: TsConfigJson): string[] {
  const refs = asArray<any>(config.references);
  const result: string[] = [];

  for (const r of refs) {
    if (!r) continue;
    const refPath = typeof r === 'string' ? r : r.path;
    if (!refPath || typeof refPath !== 'string') continue;

    const abs = normalizeRefPath(tsconfigPath, refPath);
    const resolved = resolveReferencedTsconfigPath(abs);
    if (resolved) result.push(resolved);
  }

  return uniq(result);
}

type GenerateOptions = { dryRun: boolean; force: boolean; verbose: boolean };

function generateBuildConfigs(
  entry: string,
  options: GenerateOptions
): { created: { src: string; out: string }[]; visitedConfigs: string[] } {
  const { dryRun, force, verbose } = options;

  const visited = new Set<string>();
  const queue: string[] = [entry];
  const created: { src: string; out: string }[] = [];

  while (queue.length) {
    const tsconfigPath = queue.shift()!;
    if (visited.has(tsconfigPath)) continue;
    visited.add(tsconfigPath);

    let cfg: TsConfigJson;
    try {
      cfg = readTsconfig(tsconfigPath);
    } catch (e) {
      console.warn(`Skipping (failed to read): ${tsconfigPath}`);
      if (verbose) console.warn(e);
      continue;
    }

    const outPath = join(dirname(tsconfigPath), 'tsconfig.build.json');
    const outExists = existsSync(outPath);
    const generatedByScript = outExists && isGeneratedByThisScript(outPath);
    if (outExists && !generatedByScript && !force) {
      if (verbose) {
        console.log(`Exists and was not generated by this script, skipping (use --force): ${outPath}`);
      }
    } else {
      const written = writeBuildTsconfig(tsconfigPath, cfg, dryRun);
      created.push({ src: tsconfigPath, out: written });
      if (verbose || dryRun) {
        const relSrc = relative(process.cwd(), tsconfigPath);
        const relOut = relative(process.cwd(), written);
        console.log(`${dryRun ? '[dry-run] ' : ''}created ${relOut} (extends ${relSrc})`);
      }
    }

    const refs = getProjectRefs(tsconfigPath, cfg);
    for (const r of refs) queue.push(r);
  }

  if (!verbose && !dryRun) {
    console.log(`Created/updated ${created.length} tsconfig.build.json file(s).`);
  }

  return { created, visitedConfigs: Array.from(visited) };
}

function createRegenerator(
  entry: string,
  options: GenerateOptions
): { run: (reason?: string) => Promise<void>; syncWatchedConfigs: (watcher: FSWatcher) => void } {
  let isRunning = false;
  let rerunRequested = false;
  let watchedConfigs = new Set<string>();

  const syncWatchedConfigs = (watcher: FSWatcher): void => {
    if (watchedConfigs.size === 0) return;
    watcher.add(Array.from(watchedConfigs));
  };

  const run = async (reason?: string): Promise<void> => {
    if (isRunning) {
      rerunRequested = true;
      return;
    }
    isRunning = true;

    try {
      do {
        rerunRequested = false;
        if (reason) {
          console.log(`Regenerating build configs (${reason})...`);
          reason = undefined;
        }
        const result = generateBuildConfigs(entry, options);
        watchedConfigs = new Set(result.visitedConfigs);
      } while (rerunRequested);
    } finally {
      isRunning = false;
    }
  };

  return { run, syncWatchedConfigs };
}

async function main(): Promise<void> {
  const { values } = parseArgs({
    args: process.argv.slice(2),
    options: {
      config: { type: 'string', short: 'c' },
      dryRun: { type: 'boolean' },
      force: { type: 'boolean' }, // overwrite files not generated by this script
      watch: { type: 'boolean', short: 'w' },
      verbose: { type: 'boolean', short: 'v' }
    }
  });

  const entry = values.config ? resolve(values.config) : null;
  if (!entry) {
    console.error('Missing required flag: --config <path/to/tsconfig.json>');
    process.exit(1);
  }
  if (!existsSync(entry)) {
    console.error(`Config file not found: ${entry}`);
    process.exit(1);
  }

  const dryRun = values.dryRun === true;
  const force = values.force === true;
  const watchMode = values.watch === true;
  const verbose = values.verbose === true;
  const options: GenerateOptions = { dryRun, force, verbose };

  const regenerator = createRegenerator(entry, options);
  await regenerator.run('initial run');

  if (!watchMode) {
    return;
  }

  console.log('Watch mode enabled, monitoring tsconfig changes...');
  const watcher = watch([], {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: { stabilityThreshold: 300, pollInterval: 100 }
  });
  regenerator.syncWatchedConfigs(watcher);

  watcher.on('change', async (filePath) => {
    console.log(`Config changed: ${filePath}`);
    await regenerator.run(`changed ${relative(process.cwd(), filePath)}`);
    regenerator.syncWatchedConfigs(watcher);
  });

  watcher.on('add', async (filePath) => {
    console.log(`Config added: ${filePath}`);
    await regenerator.run(`added ${relative(process.cwd(), filePath)}`);
    regenerator.syncWatchedConfigs(watcher);
  });

  watcher.on('unlink', async (filePath) => {
    console.log(`Config removed: ${filePath}`);
    await regenerator.run(`removed ${relative(process.cwd(), filePath)}`);
    regenerator.syncWatchedConfigs(watcher);
  });
}

main().catch((err) => {
  console.error('Error:', err);
  process.exit(1);
});
